package garden.appl.mitch.files

import android.Manifest
import android.app.Activity
import android.content.ContentValues
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.net.Uri
import android.os.Build
import android.os.Environment
import android.provider.MediaStore
import android.util.Log
import androidx.core.app.ActivityCompat
import androidx.core.content.ContextCompat
import garden.appl.mitch.FILE_PROVIDER
import garden.appl.mitch.Mitch
import garden.appl.mitch.PERMISSION_REQUEST_DOWNLOADS_VIEW_INTENT
import garden.appl.mitch.PERMISSION_REQUEST_MOVE_TO_DOWNLOADS
import garden.appl.mitch.PERMISSION_REQUEST_START_DOWNLOAD
import garden.appl.mitch.Utils
import garden.appl.mitch.ui.MitchActivity
import jodd.net.MimeTypes
import java.io.BufferedInputStream
import java.io.File
import java.io.FileInputStream

class ExternalFileManager {
    companion object {
        private const val LOGGING_TAG = "ExternalFileManager"
    }

    private var lastUploadId: Int = 0
    private lateinit var moveToDownloadsCallback: (Uri?) -> Unit
    private lateinit var requestPermissionCallback: () -> Unit
    
    private lateinit var lastExternalFileUri: Uri
    private lateinit var getViewIntentCallback: (Intent?) -> Unit

    /**
     * Move a completed download to downloads folder.
     * Will request permission if necessary.
     * @param activity activity which might request permission (must implement [Activity.onRequestPermissionsResult]
     * @param uploadId downloaded file to move
     * @param callback function which receives the new file name: it should be usable with [getViewIntent]
     */
    fun moveToDownloads(activity: MitchActivity, uploadId: Int, callback: (Uri?) -> Unit) {
        if (ContextCompat.checkSelfPermission(activity, Manifest.permission.WRITE_EXTERNAL_STORAGE) ==
                PackageManager.PERMISSION_GRANTED) {
            val newFileName = doMoveToDownloads(activity, uploadId)
            callback(newFileName)
        } else {
            lastUploadId = uploadId
            moveToDownloadsCallback = callback
            ActivityCompat.requestPermissions(
                activity, arrayOf(Manifest.permission.WRITE_EXTERNAL_STORAGE),
                PERMISSION_REQUEST_MOVE_TO_DOWNLOADS
            )
        }
    }
    
    fun resumeMoveToDownloads(context: Context) {
        val newFileName = doMoveToDownloads(context, lastUploadId)
        moveToDownloadsCallback(newFileName)
    }

    private fun doMoveToDownloads(context: Context, uploadId: Int): Uri? {
        val file = Mitch.installDownloadManager.getDownloadedFile(uploadId)
        return doMoveToDownloads(context, file)
    }

    /**
     * Move a completed download to downloads folder.
     * Will NOT handle permissions on Android < 33, request permissions beforehand
     */
    fun doMoveToDownloads(context: Context, file: File?): Uri? {
        if (file?.exists() != true) {
            return null
        }
        val resolver = context.contentResolver
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            val contentValues = ContentValues().apply {
                put(MediaStore.MediaColumns.DISPLAY_NAME, file.name)
                put(MediaStore.MediaColumns.MIME_TYPE, MimeTypes.getMimeType(file.extension))
                put(MediaStore.MediaColumns.SIZE, file.length())
            }
            val uri = resolver.insert(MediaStore.Downloads.EXTERNAL_CONTENT_URI, contentValues)
                ?: return null
            resolver.openOutputStream(uri).use { outputStream ->
                BufferedInputStream(FileInputStream(file)).use { inputStream ->
                    inputStream.transferTo(outputStream)
                }
            }
            return uri
        } else {
            val downloadsDir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS)

            var attemptBaseName = file.nameWithoutExtension
            val extension = file.extension

            var i = 0
            while (true) {
                try {
                    var newFile = File(downloadsDir, "$attemptBaseName.$extension")
                    if (!file.renameTo(newFile)) {
                        newFile = file.copyTo(newFile)
                        file.delete()
                    }
                    return Utils.getIntentUriForFile(context, newFile, FILE_PROVIDER)
                } catch (e: FileAlreadyExistsException) {
                    i++
                    attemptBaseName = "${file.nameWithoutExtension}-$i"
                }
            }
        }
    }

    /**
     * Get intent for viewing an externally saved file
     * @param activity activity which might request permission (must implement [Activity.onRequestPermissionsResult]
     * @param externalFileUriOrName external file name generated by [moveToDownloads]
     * @param callback function which receives the intent. Receives null if file no longer exists
     */
    fun getViewIntent(activity: Activity, externalFileUri: Uri, callback: (Intent?) -> Unit) {
        Log.d(LOGGING_TAG, "Opening $externalFileUri")
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU
            || ContextCompat.checkSelfPermission(activity, Manifest.permission.READ_EXTERNAL_STORAGE) ==
                PackageManager.PERMISSION_GRANTED) {
            val intent = getViewIntent(externalFileUri)
            callback(intent)
            return
        }

        lastExternalFileUri = externalFileUri
        getViewIntentCallback = callback
        ActivityCompat.requestPermissions(activity, arrayOf(Manifest.permission.READ_EXTERNAL_STORAGE),
            PERMISSION_REQUEST_DOWNLOADS_VIEW_INTENT)
    }
    
    fun resumeGetViewIntent() {
        val intent = getViewIntent(lastExternalFileUri)
        getViewIntentCallback(intent)
    }

    fun getViewIntent(externalFileUri: Uri): Intent {
        return Intent(Intent.ACTION_VIEW).apply {
            data = externalFileUri
            addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
            addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
        }
    }

    fun requestPermissionIfNeeded(activity: MitchActivity, callback: () -> Unit) {
        if (ContextCompat.checkSelfPermission(activity, Manifest.permission.WRITE_EXTERNAL_STORAGE) ==
            PackageManager.PERMISSION_GRANTED) {
            callback()
        } else {
            requestPermissionCallback = callback
            ActivityCompat.requestPermissions(
                activity, arrayOf(Manifest.permission.WRITE_EXTERNAL_STORAGE),
                PERMISSION_REQUEST_START_DOWNLOAD
            )
        }
    }

    fun resumeRequestPermission() {
        requestPermissionCallback()
    }
}